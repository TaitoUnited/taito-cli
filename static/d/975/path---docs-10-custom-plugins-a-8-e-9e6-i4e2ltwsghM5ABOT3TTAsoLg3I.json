{"data":{"markdownRemark":{"id":"0868a447-c5d2-5d9b-b19a-e00380febcb1","html":"<h2>10. Custom plugins</h2>\n<blockquote>\n<p>Before implementing your own custom plugin, you should browse through existing <a href=\"https://github.com/search?q=topic%3Ataito-extension&#x26;type=Repositories\">extensions</a>, as they already might provide what you are looking for.</p>\n</blockquote>\n<h3>The basics</h3>\n<p>You can implement your plugin with almost any programming language. The only requirement is that your plugin provides taito command implementations as executable files. Bash is a good choice for a simple implementation that gets the job done by calling an existing command line tool. Python or JavaScript are preferred for more complex stuff, especially, if you need to interract with a REST or GraphQL API.</p>\n<blockquote>\n<p>See <a href=\"https://github.com/TaitoUnited/taito-cli/tree/master/examples/project-and-extension\">project-and-extension</a> as an example. It is a project that uses a custom extension that is located in the project subdirectory. TODO examples for Python and JavaScript.</p>\n</blockquote>\n<p>This is how you implement your own custom plugin:</p>\n<ol>\n<li>\n<p>First create a directory that works as a Taito CLI extension. It is basically a collection of plugins:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">my-extension/\n my-plugin/\n another-plugin/</code></pre></div>\n</li>\n<li>\n<p>Add <code class=\"language-text\">package.json</code> and <code class=\"language-text\">taito-config.sh</code> files to the root directory of your extension (<code class=\"language-text\">my-extension</code>). Minimal <code class=\"language-text\">package.json</code> and <code class=\"language-text\">taito-config.sh</code> contents for supporting unit tests:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token punctuation\">{</span>\n <span class=\"token string\">\"scripts\"</span><span class=\"token keyword\">:</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token string\">\"unit\"</span><span class=\"token keyword\">:</span> <span class=\"token string\">\"taito -- find . -name \\\"*.bats\\\" -type f -prune -exec bats '{}' +\"</span>\n <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token shebang important\">#!/bin/sh</span>\n<span class=\"token comment\"># shellcheck disable=SC2034</span>\ntaito_image<span class=\"token operator\">=</span><span class=\"token string\">\"taitounited/taito-cli:latest\"</span>\ntaito_plugins<span class=\"token operator\">=</span><span class=\"token string\">\"npm\"</span></code></pre></div>\n</li>\n<li>\n<p>Add some executable commands to one of the plugins as <code class=\"language-text\">.sh</code>, <code class=\"language-text\">.py</code>, <code class=\"language-text\">.js</code> or <code class=\"language-text\">.x</code> files). Optionally add also documentation in help.txt, trouble.txt and README.md files. With the #pre and #post prefixes you can define that your command should be run in pre or post phase instead of the normal execute phase (more on that later).</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">my-plugin/\n resources/\n   my-script.sql\n util/\n   my-util.sh\n my-command.bats\n my-command.sh\n env-apply<span class=\"token comment\">#post.bats</span>\n env-apply<span class=\"token comment\">#post.sh</span>\n env-apply<span class=\"token comment\">#pre.bats</span>\n env-apply<span class=\"token comment\">#pre.sh</span>\n help.txt\n README.md\n trouble.txt</code></pre></div>\n</li>\n<li>\n<p>Optionally you can also add pre and post hooks to your plugin. These will be called before and after any other commands despite the command name. Exit with code 0 if execution should be continued, code 1 if handler encountered an error and code 2 if everything went ok, but execution should not be continued nevertheless. See npm plugin as an example.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">my-plugin/\n hooks/\n   pre.sh\n   post.sh</code></pre></div>\n</li>\n<li>\n<p>Add the extension directory to your <em>taito</em>global<em>extensions</em> or <em>taito</em>extensions_ definition and the plugin to your <em>taito</em>global<em>plugins</em> or <em>taito</em>plugins_ definition. You can reference extension either by file path or git url.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">taito_extensions<span class=\"token operator\">=</span><span class=\"token string\">\"git@github.com:JohnDoe/my-extension.git\"</span>\ntaito_plugins<span class=\"token operator\">=</span><span class=\"token string\">\"my-plugin\"</span></code></pre></div>\n</li>\n<li>\n<p>Implement unit tests for your commands with <a href=\"https://github.com/bats-core/bats-core\">bats</a>. See <code class=\"language-text\">.bats</code> files under <code class=\"language-text\">taito-cli/plugins</code> as an example. You can run your unit tests with the <code class=\"language-text\">taito unit</code> command.</p>\n</li>\n<li>\n<p>Optionally provide autocomplete and descriptions support for you commands by adding <code class=\"language-text\">autocomplete.sh</code> and <code class=\"language-text\">descriptions.sh</code> to the root folder of your extension. See <a href=\"https://github.com/TaitoUnited/taito-cli/blob/master/plugins/autocomplete.sh\">autocomplete.sh</a> and <a href=\"https://github.com/TaitoUnited/taito-cli/blob/master/plugins/descriptions.sh\">descriptions.sh</a> as an example.</p>\n</li>\n</ol>\n<p>Now you should be able to call <code class=\"language-text\">taito my command</code>. And when you call <code class=\"language-text\">taito env apply</code>, your <code class=\"language-text\">env-apply#pre</code> and <code class=\"language-text\">env-apply#post</code> commands will be called before and after all <code class=\"language-text\">env-apply</code> commands defined by other enabled plugins. And if you defined also pre and post hooks, they will be called before and after any commands despite the command name.</p>\n<p>Note that you can also add a project specific extension to your project subdirectory and reference it like this in <em>taito-config.sh</em>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">taito_extensions=&quot;./scripts/my-extension&quot;\ntaito_plugins=&quot;my-plugin&quot;</code></pre></div>\n<p>NOTE: Always remember to call the next command of the command chain at some point during command execution (usually at the end) unless you want to stop the command chain execution:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&quot;${taito_cli_path}/util/call-next.sh&quot; &quot;${@}&quot;</code></pre></div>\n<p>NOTE: Do not call another command directly from another. It's error prone; you'll easily mess up the command chain execution, and also clarity of user friendly info messages. Place the common logic shared by multiple commands in a separate util instead.</p>\n<h3>Output in verbose and debug mode</h3>\n<p>Values of the following environment variables are set depending on debug mode:</p>\n<ul>\n<li><strong>taito_debug</strong>: <code class=\"language-text\">true</code> or <code class=\"language-text\">false</code></li>\n<li><strong>taito_dout</strong>: <code class=\"language-text\">/dev/stdout</code> or <code class=\"language-text\">/dev/null</code></li>\n</ul>\n<p>Values of the following environment variables are set depending on verbose mode:</p>\n<ul>\n<li><strong>taito_verbose</strong>: <code class=\"language-text\">true</code> or <code class=\"language-text\">false</code></li>\n<li><strong>taito_vout</strong>: <code class=\"language-text\">/dev/stdout</code> or <code class=\"language-text\">/dev/null</code></li>\n<li><strong>taito_setv</strong>: <code class=\"language-text\">set -x</code> or <code class=\"language-text\">:</code></li>\n</ul>\n<p>You can use these environment variables to provide additional output in verbose or debug mode. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">echo &quot;Additional debug output&quot; &gt; ${taito_dout}\necho &quot;Additional verbose output&quot; &gt; ${taito_vout}\n(${taito_setv}; kubectl get pods) # The command will printed in verbose mode</code></pre></div>\n<h3>Running commands on host</h3>\n<p>If your plugin needs to run some commands on host machine, execute <code class=\"language-text\">&quot;${taito_cli_path}/util/execute-on-host.sh&quot; COMMANDS</code> to run them immediately in the background. Alternatively you can use the <code class=\"language-text\">&quot;${taito_cli_path}/util/execute-on-host-fg.sh&quot; COMMANDS</code> to run the commands on foreground after the taito container has exited. Note that if some of the commands might require user input, you must run the commands on foreground.</p>\n<p>Currently this mechanism is used e.g. for executing docker commands on host and launching browser.</p>\n<h3>Committing changes to the Taito CLI container image</h3>\n<p>If your plugin needs to save some data permanently on the container image, execute <code class=\"language-text\">&quot;${taito_cli_path}/util/docker-commit.sh&quot;</code>. This asks host to commit changes permanently on the container image. Currently this mechanism is used e.g. in authentication to save credentials on the image.</p>\n<h3>Command chains and passing data</h3>\n<p>When a given command name matches to multiple commands, all commands are chained in series so that each command calls the next. Command execution is ordered primarily by the execution phase (pre, command, post) and secondarily by the order of the plugins in <em>taito-config.sh</em>.</p>\n<p>Passing data between commands/phases works simply by exporting environment variables. To avoid naming conflicts between plugins, use your plugin name as a prefix for your exported environment variables. Or if the purpose is to pass data between different plugins, try to come up with some good standardized variable names and describe them in the <a href=\"#environment-variables\">environment variables</a> chapter.</p>\n<p>Here is an example how chaining could be used e.g. to implement secret rotation by integrating an external secret manager:</p>\n<ol>\n<li>Pre-hook of a secret manager plugin gathers all secrets that need to be rotated (e.g. database passwords) and generates new secrets for them.</li>\n<li>A database plugin deploys the new database passwords to database.</li>\n<li>The kubectl plugin deploys the secrets to Kubernetes and executes a rolling restart for the pods that use them.</li>\n<li>Post-hook of the secret manager plugin stores the new secrets to a secure location using some form of encryption, or just updates the secret timestamps if the secrets need not be stored.</li>\n</ol>\n<h3>Overriding existing commands</h3>\n<p>If you need to alter default behaviour of a plugin in some way, you can override a single command of a plugin without disabling the whole plugin:</p>\n<ul>\n<li>Create a plugin that provides an alternative implementation for the command</li>\n<li>Create a pre command that removes the original command from command chain (TODO reusable script for this)</li>\n<li>Make sure that your plugin is given first in the <code class=\"language-text\">taito_plugins</code> setting of your <code class=\"language-text\">taito-config.sh</code> file in project root directory.</li>\n</ul>\n<h3>Environment variables</h3>\n<h4>Common variables</h4>\n<p>All settings defined in <code class=\"language-text\">taito-config.sh</code> are visible for plugins. See <a href=\"/docs/04-configuration\">configuration</a> chapter for more info. Additionally the following environment variables are defined by Taito CLI:</p>\n<ul>\n<li><strong>taito_env</strong>: The selected environment (e.g. local, feat-NAME, dev, test, stag, canary, prod)</li>\n<li><strong>taito<em>target</em>env</strong>: TODO ....</li>\n<li><strong>taito_target</strong>: Command target (e.g. admin, client, server, worker, ...)</li>\n<li><strong>taito_command</strong>: The user given command without the target and environment suffix.</li>\n<li><strong>taito<em>enabled</em>extensions</strong>: List of all enabled extensions.</li>\n<li><strong>taito<em>enabled</em>plugins</strong>: List of all enabled plugins.</li>\n<li><strong>taito<em>skip</em>override</strong>: True if command overrides should be skipped.</li>\n<li><strong>taito<em>cli</em>path</strong>: Path to Taito CLI root directory.</li>\n<li><strong>taito<em>plugin</em>path</strong>: Path to root directory of the current plugin.</li>\n<li><strong>taito<em>project</em>path</strong>: Path to project root directory.</li>\n<li><strong>taito<em>command</em>chain</strong>: Chain of commands to be executed next.</li>\n<li><strong>taito_verbose</strong>: <code class=\"language-text\">true</code> in verbose mode, otherwise <code class=\"language-text\">false</code>.</li>\n<li><strong>taito_setv</strong>: <code class=\"language-text\">set -x</code> in verbose mode, otherwise <code class=\"language-text\">:</code>.</li>\n<li><strong>taito_vout</strong>: <code class=\"language-text\">/dev/stdout</code> in verbose mode, otherwise <code class=\"language-text\">/dev/null</code>.</li>\n</ul>\n<p>TODO update the list of environment variables</p>\n<h4>Standardized variable names</h4>\n<p>These variable names are meant for communication between plugins.</p>\n<p>Secrets:</p>\n<p>TODO add documentation</p>\n<h3>Tips</h3>\n<ul>\n<li><a href=\"https://gist.github.com/magnetikonline/90d6fe30fc247ef110a1\">Bash string manipulation cheatsheet</a></li>\n</ul>\n<hr>\n<p><strong>Next:</strong> <a href=\"/docs/11-custom-project-templates\">11. Custom project templates</a></p>"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"0868a447-c5d2-5d9b-b19a-e00380febcb1"}}