{"data":{"tutorial":{"id":"64c9ed3b-6893-5927-9d97-72bd14b54630","html":"<h2>2. Local development</h2>\n<h3>2.1. Start the application</h3>\n<p>The template uses Docker Compose to run your application. All parts of the application, including the database, are run inside containers so that the running environment closely resembles the actual production environment.</p>\n<p>Start the application with the following commands:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">taito kaboom        <span class=\"token comment\"># Clean start local development environment</span>\n                    <span class=\"token comment\"># (Runs env apply --clean, start --clean, init --clean)</span>\ntaito <span class=\"token function\">open</span> client   <span class=\"token comment\"># Open application web user interface</span>\ntaito info          <span class=\"token comment\"># Show info required for signing in to the application</span></code></pre></div>\n<p>Installation and starting up takes some time the first time you run the commands, as Docker containers and npm libraries need to be downloaded first. While waiting, browse through the <a href=\"https://github.com/TaitoUnited/server-template/blob/master/DEVELOPMENT.md#quick-start\">Quick start</a> section of the DEVELOPMENT.md file to get an quick overview of the Taito CLI commands.</p>\n<h3>2.2. Implement a new page with React</h3>\n<p>Make up some simple idea that you would like to implement, and add a new empty page for it. If you don't come up with any idea yourself, just reimplement the posts page that lets you add new posts, but replace posts with articles. Don't worry about API or database for now. Just implement a dummy user interface that works, but doesn't actually store data anywhere permanently.</p>\n<p>If you are not yet familiar with <a href=\"https://reactjs.org/\">React</a>, you should implement the UI state management using only functionality that React provides out-of-the-box. <a href=\"a-technology-tutorials\">Appendix A: Technology tutorials</a> provides some tips and other resources that might be useful while learning React, HTML and CSS. If you already know React, you may choose to use additional libraries like <a href=\"https://redux.js.org/\">Redux</a> and <a href=\"https://redux-saga.js.org/\">redux-saga</a> for managing state and side effects.</p>\n<p>The application is built automatically in the background when you make changes. If build fails for some reason, you should see errors on your command line console. Note that you should also install <a href=\"https://eslint.org/docs/user-guide/integrations#editors\">eslint</a> and <a href=\"https://prettier.io/docs/en/editors.html\">prettier</a> plugins to your code editor <em>(TODO: tslint instead of eslint?)</em>. This way you see linting errors directly in your editor, and code will be formatted automatically according to predefined rules.</p>\n<p>You can debug the implementation with your web browser. <a href=\"https://developers.google.com/web/tools/chrome-devtools/\">Chrome DevTools</a> is a set of web developer tools built directly into the Google Chrome browser. Other web browsers include similar tools also. These tools let you examine generated HTML, change CSS styles directly in browser, and debug implementation by setting breakpoints and executing code line by line in browser. Note that you can find source code of your UI implementation under the webpack folder: <strong>Chrome DevTools</strong> -> <strong>Sources tab</strong> -> <strong>webpack://</strong> -> <strong>.</strong> -> <strong>src</strong>. See <a href=\"a-technology-tutorials.md#browser-extensions\">appendix A</a> for some additional browser extensions that might also be useful.</p>\n<blockquote>\n<p>If web development is new for you and you are insterested, just take your time learning the web development basics before continuing the Taito CLI tutorial.</p>\n</blockquote>\n<h3>2.3. Add a new npm library dependency</h3>\n<p>Add some npm library to the dependencies section of the <code class=\"language-text\">client/package.json</code>, run <code class=\"language-text\">taito install</code>, and restart the application with <code class=\"language-text\">ctrl-c</code>, <code class=\"language-text\">taito start</code>. Now you should be able to use the npm library in your implementation.</p>\n<h3>2.4. Commit and push changes to git</h3>\n<p>Once in a while commit and push your changes to git. You can do this either with a GUI tool of some sort (e.g. your code editor) or on command line with the following commands.</p>\n<p>Committing changes to a local git repository:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> <span class=\"token function\">add</span> -A                                     <span class=\"token comment\"># Add all changed files to staging area</span>\n<span class=\"token function\">git</span> commit -m <span class=\"token string\">'wip(articles): user interface'</span>  <span class=\"token comment\"># Commit all staged changes to the local git repository</span></code></pre></div>\n<p>Pulling changes from and pushing changes to a remote git repository:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> pull -r           <span class=\"token comment\"># Pull changes from remote git repository using rebase</span>\n<span class=\"token function\">git</span> push              <span class=\"token comment\"># Push changes to remote git repository</span></code></pre></div>\n<p>For now, you should commit all your changes to the dev branch that is checked out by default. You should also write commit messages in the following format: <code class=\"language-text\">wip(articles): my short lowercase message</code>. Branches and commit message conventions are explained later in chapter <a href=\"/tutorial/03-version-control\">3. Version control</a>.</p>\n<blockquote>\n<p>TIP: <code class=\"language-text\">git pull -r</code> refuses to run if your worktree is dirty. In such case, you can run <code class=\"language-text\">git pull -r --autostash</code> if you don't want to commit or stash your changes before pull.</p>\n</blockquote>\n<blockquote>\n<p>TIP: You can configure git to always rebase by default on pull with <code class=\"language-text\">git config --global pull.rebase true</code>.</p>\n</blockquote>\n<h3>2.5. Add a database table</h3>\n<p>Your implementation needs to store some data permanently. For this, you create 1-N database tables to PostgreSQL database. You add a new database table by adding a new database migration. You can do this with the following commands:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">taito db add: articles -n <span class=\"token string\">'add articles table'</span>  <span class=\"token comment\"># Add migration</span>\nEDIT database/deploy/articles.sql               <span class=\"token comment\"># Edit deploy script</span>\nEDIT database/revert/articles.sql               <span class=\"token comment\"># Edit revert script</span>\nEDIT database/verify/articles.sql               <span class=\"token comment\"># Edit verify script</span>\ntaito init                                      <span class=\"token comment\"># Deploy to local db</span></code></pre></div>\n<p>TODO: or <code class=\"language-text\">taito init --clean</code>?</p>\n<p>The <em>deploy.sql</em> script creates a database table, the <em>verify.sql</em> script verifies that the database table exists, and the <em>revert.sql</em> script reverts the changes by dropping the database table. You can find example deploy, revert and verify scripts in the <code class=\"language-text\">database/</code> directory. These migration scripts will be run automatically by <a href=\"https://en.wikipedia.org/wiki/CI/CD\">CI/CD pipeline</a> when the application is deployed to different environments (e.g. local, development, testing, staging, canary, production).</p>\n<p>Migrations are executed with Sqitch. See <a href=\"https://metacpan.org/pod/sqitchtutorial\">Sqitch tutorial for PostgreSQL</a> if you need further instructions on editing the migration scripts. See <a href=\"a-technology-tutorials.md#sql-and-relational-databases\">appendix A</a> for some SQL and relational database tutorials.</p>\n<h3>2.6. Add some example data to database</h3>\n<p>Often it's a good idea to add some example data to database, as it makes development and testing easier. Folder <code class=\"language-text\">database/data/</code> contains example data for each environment. Try to add some example data to the newly created database table(s) with the following commands:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">EDIT database/data/dev.sql     <span class=\"token comment\"># Modify data used for local and dev environments</span>\ntaito init --clean             <span class=\"token comment\"># Populate all migrations and init data to local database</span></code></pre></div>\n<p>Note that <code class=\"language-text\">taito init --clean</code> erases all existing data from your local database. If you don't want that, you can alternatively run <code class=\"language-text\">taito init</code> and ignore all the <strong>already exists</strong> error messages.</p>\n<blockquote>\n<p>TODO: note about remote environments and <code class=\"language-text\">taito init:dev --clean</code>.</p>\n</blockquote>\n<h3>2.7. Connect to the local database</h3>\n<p>Connect to your local database and check that the example data exists there. You can do this with the following commands:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">taito db connect        <span class=\"token comment\"># Connect to the local database</span>\n\\dt                     <span class=\"token comment\"># Show all database tables (postgres)</span>\n<span class=\"token keyword\">select</span> * from articles<span class=\"token punctuation\">;</span> <span class=\"token comment\"># Show all articles (SQL command)</span>\n\\?                      <span class=\"token comment\"># Show help for all backslash commands (postgres)</span>\n\\q                      <span class=\"token comment\"># Quit (postgres)</span></code></pre></div>\n<p>If you are not yet familiar with SQL, you should try to execute also some additional SQL commands just for the fun of it. See <a href=\"a-technology-tutorials.md#sql-and-relational-databases\">appendix A</a> for some SQL tutorials.</p>\n<blockquote>\n<p>TIP: If you have installed some database GUI tool, you can run <code class=\"language-text\">taito db proxy</code> to display database connection details and you can use those details to connect to the local database.</p>\n</blockquote>\n<h3>2.8. Modify an existing database table</h3>\n<p>Normally all database changes must be made using database migrations (option a). However, if you are modifying a database table that does not exist in production environment yet, you can keep the scripts located in <code class=\"language-text\">database/deploy/</code> cleaner by modifying them directly (option b). Try the both approaches:</p>\n<h4>a) With migrations</h4>\n<p>Add a new column to your newly created database table as a new database migration. You do this just like you added the database table, but this time you use <code class=\"language-text\">ALTER TABLE</code> clause instead of <code class=\"language-text\">CREATE TABLE</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">taito db add: articles-foobar -n <span class=\"token string\">'add foobar column to articles table'</span>  <span class=\"token comment\"># Add migration</span>\nEDIT database/deploy/articles-foobar.sql                                <span class=\"token comment\"># Edit deploy script</span>\nEDIT database/revert/articles-foobar.sql                                <span class=\"token comment\"># Edit revert script</span>\nEDIT database/verify/articles-foobar.sql                                <span class=\"token comment\"># Edit verify script</span>\ntaito init                                                              <span class=\"token comment\"># Deploy to local db</span></code></pre></div>\n<p>The <em>deploy.sql</em> script creates the column, the <em>verify.sql</em> script verifies that the column exists, and the <em>revert.sql</em> script reverts the changes by dropping the column. You can find example deploy, revert and verify scripts in the <code class=\"language-text\">database/</code> directory. Note that you can also add multiple columns in a single migration script, if necessary. See <a href=\"https://metacpan.org/pod/sqitchtutorial\">Sqitch tutorial for PostgreSQL</a> if you need further instructions.</p>\n<p>The upside of this approach is that the new column is deployed to all environments automatically. Other developers need to run <code class=\"language-text\">taito init</code> manually, but <code class=\"language-text\">taito init --clean</code> is not required, and therefore all data is preserved.</p>\n<p>TODO example: posts-images</p>\n<h4>b) By modifying existing scripts</h4>\n<p>Add a new column to your newly created database table by modifying the existing deploy script directly:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">EDIT database/deploy/articles.sql  <span class=\"token comment\"># Edit deploy script</span>\ntaito init --clean                 <span class=\"token comment\"># Deploy to local db</span></code></pre></div>\n<p>The downside of this approach is that the <code class=\"language-text\">taito init:ENV --clean</code> command deletes all existing data from database, and the command must be run manually to all environments that already contain the database table that was modified.</p>\n<h3>2.9. Implement API</h3>\n<p>Your UI implementation needs to access the data located in database. However, accessing database directly from UI is a bad approach for many reasons. Therefore you need to implement an API that exists between the UI and the database:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">UI <span class=\"token punctuation\">(</span>on browser<span class=\"token punctuation\">)</span>  -<span class=\"token operator\">></span>  API <span class=\"token punctuation\">(</span>on server<span class=\"token punctuation\">)</span>  -<span class=\"token operator\">></span>  database</code></pre></div>\n<p>The API should be stateless. That is, the API implementatino should not keep any state in memory or on local disk between requests. This is explained in more detail in <a href=\"b-software-design.md#api-design\">appendix B</a>.</p>\n<p>TODO: Some tips for debugging.</p>\n<h4>a) RESTful API</h4>\n<p>Implement a RESTful API endpoint for your UI and modify your UI implementation to use the API endpoint. See <code class=\"language-text\">server/src/content/posts.*</code> as an example. In a RESTful API a HTTP URL (e.g <em>/posts</em>) defines a resource, and HTTP methods (GET, POST, PUT, PATCH, DELETE) operate on that resource. For example:</p>\n<ul>\n<li><code class=\"language-text\">GET /articles</code>: Fetch all articles from the articles collection</li>\n<li><code class=\"language-text\">POST /articles</code>: Create a new article to the articles collection</li>\n<li><code class=\"language-text\">GET /articles/432</code>: Read article 432</li>\n<li><code class=\"language-text\">PUT /articles/432</code>: Update article 432 (all fields)</li>\n<li><code class=\"language-text\">PATCH /articles/432</code>: Update article 432 (only given fields)</li>\n<li><code class=\"language-text\">DELETE /articles/432</code>: Delete article 432</li>\n</ul>\n<p>See <a href=\"a-technology-tutorials.md#restful-api\">appendix A</a> for some RESTful API tutorials.</p>\n<h4>b) GraphQL API</h4>\n<p>TODO: Later</p>\n<p>See <a href=\"a-technology-tutorials.md#graphql-api\">appendix A</a> for some GraphQL API tutorials.</p>\n<h3>2.10. Use environment variables for configuration</h3>\n<p>Your implementation will be run in many other environments in In addition to your local environment (testing environment and production environment, for example). Some settings, like database settings, change depending on the environment. You can define these settings with environment variables.</p>\n<ol>\n<li>Add a new environment variable for server container in <code class=\"language-text\">docker-compose.yaml</code>.</li>\n<li>Add the new environment variable to <code class=\"language-text\">server/src/common/config.js</code>.</li>\n<li>Try using the environment variable in your server implementation. For example add the environment variable to the <code class=\"language-text\">/config</code> endpoint in <code class=\"language-text\">server/src/infra/infra.route.js</code> and see if <code class=\"language-text\">/api/config</code> endpoint returns the configured value to your browser.</li>\n<li>Add the environment variable also to <code class=\"language-text\">scripts/helm.yaml</code>. The helm.yaml file is used for Kubernetes running on remote environments, but you should add the environment variable right away, so that you don't forget to do it later. You can use <code class=\"language-text\">TODO</code> as value, if you don't know the correct value yet.</li>\n</ol>\n<p>Note that you should not use environment variables to define passwords or other secrets. Configuring remote environments and secrets are explained in part II of the tutorial.</p>\n<p>TODO: change current docker-compose.yaml implementation -> mount secrets</p>\n<h3>2.11. Use 3rd party services and define secrets</h3>\n<p>You should not worry about 3rd party services and secrets for now. These are explained in part II of the tutorial.</p>\n<h3>2.12. Store files to object storage</h3>\n<p>TODO: As noted previously, no local disk.</p>\n<p>TODO: <a href=\"https://cloud.google.com/storage/docs/access-control/signing-urls-manually\">https://cloud.google.com/storage/docs/access-control/signing-urls-manually</a>\nTODO: minio -> S3 compatible (google cloud, etc.)</p>\n<h3>2.13. Use transactions to preserve data integrity</h3>\n<p>Data changes made by a service should be atomic to preserve data integrity. That is, if <code class=\"language-text\">PUT /articles/432</code> modifies data located in multiple database tables, either all data updates should be completed or none of them should.</p>\n<h4>a) Transactions with a relational database</h4>\n<p>With relational databases you can use transactions to achieve atomicity. The full-stack-template starts a transaction automatically for all POST, PUT, PATCH and DELETE requests (see <code class=\"language-text\">server/src/infra/transaction.middleware.js</code>). This is a good default for most cases. See chapter <a href=\"/tutorial/09-full-stack-template-specific\">10. full-stack-template specific details</a> if you'd like to know how to customize your transactions.</p>\n<p>Try if transactions work like they should:</p>\n<ol>\n<li>\n<p>Add few posts using the UI. Also check that they appear in the database: <code class=\"language-text\">taito db connect</code>, <code class=\"language-text\">select * from posts order by created_at desc</code></p>\n</li>\n<li>\n<p>Edit <code class=\"language-text\">posts.service.js</code> and add a line that throws an error after post has been added to database:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">async create<span class=\"token punctuation\">(</span>state, post<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n authorize<span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span>.role<span class=\"token punctuation\">(</span><span class=\"token string\">'admin'</span>, <span class=\"token string\">'user'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n const <span class=\"token function\">id</span> <span class=\"token operator\">=</span> await this.postDB.create<span class=\"token punctuation\">(</span>state.getTx<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>, post<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span> throw new Error<span class=\"token punctuation\">(</span><span class=\"token string\">'error'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">return</span> this.postDB.read<span class=\"token punctuation\">(</span>state.getTx<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>, id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>Try adding some posts on the UI. You should notice that new posts won't appear in database even though the error is thrown only after each post is created.</p>\n</li>\n</ol>\n<h4>b) Transactions and multiple systems</h4>\n<p>Using a database transaction does not always suffice if an operation makes data changes to multiple systems. However, if only two systems are involved (e.g. database + object storage), you can often mitigate this issue just by executing the updates in a correct order. You should make all database updates first and only then write data to object storage. This way database updates will be rolled back automatically if the object storage write fails. In a more complex scenario, you might need to catch some errors yourself and revert data changes manually.</p>\n<p>Try this yourself by modifying the implementation that you made in exercise 2.10. Try both 1. and 2., and see how they behave when an error occurs during either database update or object storage write:</p>\n<ul>\n<li>\n<ol>\n<li>write to database, write to object storage</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>write to object storage, write to database</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>Some systems support distributed transactions. That is, you can make changes to multiple systems at once, and all of them engage to the same transaction. Distributed transactions come with extra complexity and are rarely needed.</p>\n</blockquote>\n<h3>2.14. Automatic testing</h3>\n<p>Test scripts are run automatically by <a href=\"https://en.wikipedia.org/wiki/CI/CD\">CI/CD pipeline</a> when the application is deployed to different environments (e.g. local, development, testing, staging, canary, production). You can also run these tests manually with the following commands:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">taito unit                  <span class=\"token comment\"># Run all unit tests</span>\ntaito <span class=\"token function\">test</span>                  <span class=\"token comment\"># Run all UI and API tests against locally running application</span></code></pre></div>\n<p>You can also run a certain subset of tests:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">taito unit:client           <span class=\"token comment\"># Run unit tests of client</span>\ntaito unit:server           <span class=\"token comment\"># Run unit tests of server</span>\ntaito test:server           <span class=\"token comment\"># Run all API tests of server against locally running application</span>\ntaito test:client cypress   <span class=\"token comment\"># Run all cypress UI tests of client against locally running application</span></code></pre></div>\n<p>You can run UI and API tests also against remote environments, but this is explained in chapter <a href=\"/tutorial/05-remote-environments\">5. Remote environments</a>.</p>\n<p>You should not test implementation in your test scripts. Instead, you should always find some kind of 'public API' that is designed not to change very often, and test behaviour of that API. Here public API can be provided by a class, module, library, service or UI for example. This way you can make changes to the underlying implementation, and the existing tests protect you from breaking anything.</p>\n<blockquote>\n<p>TODO: TDD or not, prototyping at beginning of the project\nTODO: Running tests in production</p>\n</blockquote>\n<h4>a) Create user interface test</h4>\n<p>full-stack-template uses <a href=\"https://www.cypress.io/\">Cypress</a> for automatic user interface tests.</p>\n<ol>\n<li>Open the Cypress UI with <code class=\"language-text\">taito cypress:client</code> and run all existing Cypress tests by pressing the <code class=\"language-text\">Run all specs</code> -button.</li>\n<li>\n<p>Create tests for you UI. See the <code class=\"language-text\">client/test/integration/posts.spec.js</code> as an example. The following resources provide some useful instructions for writing Cypress tests:</p>\n<ul>\n<li><a href=\"https://docs.cypress.io/guides/getting-started/writing-your-first-test.html\">writing-your-first-test</a></li>\n<li><a href=\"https://docs.cypress.io/guides/references/best-practices.html\">best-practices</a></li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>TIP: By default, Cypress tests are end-to-end tests. That is, they test functionality all the way from the UI to the database. This is not always a good thing. Your tests may become fragile if they are dependent on 3rd party services or on data that you cannot easily control during the test run. Your tests may also perform poorly, and you easily test the same functionality twice if you already have API tests in place. See <a href=\"https://docs.cypress.io/guides/guides/network-requests.html\">Network Requests\n</a> for more information.</p>\n</blockquote>\n<h4>b) Create API test</h4>\n<p>The api test examples use <a href=\"https://mochajs.org/\">Mocha</a> as testing framework and <a href=\"https://www.chaijs.com/\">Chai</a> for assertions.</p>\n<ol>\n<li>Run all existing API tests with <code class=\"language-text\">taito test:server</code>.</li>\n<li>\n<p>Create tests for your API endpoint. See the <code class=\"language-text\">server/src/content/posts.test.js</code> as an example. The following resources provide some useful instructions for writing tests:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">TODO</code></pre></div>\n</li>\n</ol>\n<h4>c) Create unit test</h4>\n<p>The full-stack-template differentiates unit tests from all other tests by using <code class=\"language-text\">unit</code> as filename suffix instead of <code class=\"language-text\">test</code>. A unit test does not require a running environment. That is, no database or external services are involved as unit test typically tests only a bunch of code. You can achieve this by <a href=\"TODO-link\">mocking</a>. TODO mock link.</p>\n<p>The unit test examples use <a href=\"https://mochajs.org/\">Mocha</a> as testing framework and <a href=\"https://www.chaijs.com/\">Chai</a> for assertions.</p>\n<ol>\n<li>Run all existing unit tests with <code class=\"language-text\">taito unit</code>.</li>\n<li>\n<p>Create unit tests for your TODO. See the <code class=\"language-text\">TODO</code> as an example. The following resources provide some useful instructions for writing tests:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">TODO</code></pre></div>\n</li>\n</ol>\n<h3>2.15. Try some additional taito commands</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">taito <span class=\"token function\">open</span> <span class=\"token function\">git</span>                 <span class=\"token comment\"># Open git repository on browser</span>\ntaito <span class=\"token function\">open</span> project             <span class=\"token comment\"># Open project management on browser</span>\ntaito <span class=\"token function\">open</span> docs                <span class=\"token comment\"># Open project documentation on browser</span>\ntaito <span class=\"token function\">open</span> ux                  <span class=\"token comment\"># Open UX guides and layouts on browser</span>\n\ntaito check size:client        <span class=\"token comment\"># Analyze size of the client</span>\ntaito check deps:server        <span class=\"token comment\"># Check dependencies of the server</span>\n\ntaito --trouble                <span class=\"token comment\"># Display troubleshooting</span>\ntaito workspace <span class=\"token function\">kill</span>           <span class=\"token comment\"># Kill all running processes (e.g. containers)</span>\ntaito workspace clean          <span class=\"token comment\"># Remove all unused build artifacts (e.g. images)</span></code></pre></div>\n<h3>2.16. Read some software design basics</h3>\n<p>If you did not already, read <a href=\"b-software-design\">Appendix B: Software design</a> for some tips on how to design your application.</p>\n<hr>\n<p><strong>Next:</strong> <a href=\"/tutorial/03-version-control\">3. Version control</a></p>"},"menu":{"edges":[{"node":{"id":"9162b0dd-c4f6-5ba0-988b-4c795a6ce66f","headings":[{"value":"1. Starting a new project"}],"fields":{"slug":"/tutorial/01-starting-a-new-project/"}}},{"node":{"id":"64c9ed3b-6893-5927-9d97-72bd14b54630","headings":[{"value":"2. Local development"}],"fields":{"slug":"/tutorial/02-local-development/"}}},{"node":{"id":"3827531b-fba0-5a2a-9084-52516d3872f3","headings":[{"value":"3. Version control"}],"fields":{"slug":"/tutorial/03-version-control/"}}},{"node":{"id":"b2030e15-dc9b-5f98-a5cf-3e3dccdd6c11","headings":[{"value":"4. Project management"}],"fields":{"slug":"/tutorial/04-project-management/"}}},{"node":{"id":"d83c3a19-3868-56cf-a5f9-b24b2af66b20","headings":[{"value":"5. Remote environments"}],"fields":{"slug":"/tutorial/05-remote-environments/"}}},{"node":{"id":"a3492616-cb8e-5f4a-b062-48d6537274e7","headings":[{"value":"6. Environment variables and secrets"}],"fields":{"slug":"/tutorial/06-env-variables-and-secrets/"}}},{"node":{"id":"121a9436-85c8-5b92-878e-f735f1eb93ff","headings":[{"value":"7. Databases and files"}],"fields":{"slug":"/tutorial/07-databases-and-files/"}}},{"node":{"id":"e748c043-1f1c-5518-80dd-80b011007d72","headings":[{"value":"8. Cloud services and Terraform"}],"fields":{"slug":"/tutorial/08-cloud-services-and-terraform/"}}},{"node":{"id":"29e65915-3efc-5834-94b8-14d162cd137f","headings":[{"value":"9. full-stack-template specific details"}],"fields":{"slug":"/tutorial/09-full-stack-template-specific/"}}},{"node":{"id":"18fc3997-3a39-5864-a5bf-e48ffc85bbfa","headings":[{"value":"10. Production setup"}],"fields":{"slug":"/tutorial/10-production-setup/"}}},{"node":{"id":"5accd1d7-2b43-5201-b38b-3aadfc1bcc78","headings":[{"value":"11. Running in production"}],"fields":{"slug":"/tutorial/11-running-in-production/"}}},{"node":{"id":"6609bb19-ef32-58a4-ad47-c9a560afa413","headings":[{"value":"12. Creating a custom command"}],"fields":{"slug":"/tutorial/12-creating-a-custom-command/"}}},{"node":{"id":"ed727541-68ed-5ffa-b500-3e2d67ee0aad","headings":[{"value":"13. Creating a custom plugin"}],"fields":{"slug":"/tutorial/13-creating-a-custom-plugin/"}}},{"node":{"id":"7c5da057-3c39-5275-b002-665f09bf652d","headings":[{"value":"14. Creating a custom template"}],"fields":{"slug":"/tutorial/14-creating-a-custom-template/"}}},{"node":{"id":"ac758a21-5898-581f-8f8a-89a8edfd94d1","headings":[{"value":"15. Creating a zone"}],"fields":{"slug":"/tutorial/15-creating-a-zone/"}}},{"node":{"id":"c697982a-07ef-554a-a3a3-041864902c34","headings":[{"value":"16. Zone maintenance"}],"fields":{"slug":"/tutorial/16-zone-maintenance/"}}},{"node":{"id":"cc1283ed-9c5b-54f3-9e58-066d00429a8e","headings":[{"value":"17. Zone monitoring"}],"fields":{"slug":"/tutorial/17-zone-monitoring/"}}},{"node":{"id":"d96b1123-f8bd-5207-864f-abc448c8a034","headings":[{"value":"18. Zone recovery"}],"fields":{"slug":"/tutorial/18-zone-recovery/"}}},{"node":{"id":"1e016b44-8bf7-5291-8a77-e33be39d3787","headings":[{"value":"APPENDIX A: Technology tutorials"}],"fields":{"slug":"/tutorial/a-technology-tutorials/"}}},{"node":{"id":"669a57d7-a9e4-5d0e-8f6b-be481ca4be38","headings":[{"value":"APPENDIX B: Software design"}],"fields":{"slug":"/tutorial/b-software-design/"}}},{"node":{"id":"97b359bc-af92-5837-937e-646a7c1751a6","headings":[{"value":"APPENDIX C: Modern server infrastructure"}],"fields":{"slug":"/tutorial/c-modern-server-infrastructure/"}}},{"node":{"id":"b6b33ce2-199f-5fce-b0a9-28f0fd30e0f9","headings":[{"value":"APPENDIX D: Security"}],"fields":{"slug":"/tutorial/d-security/"}}},{"node":{"id":"143d54e6-a662-5fe2-9b4d-5b3d8b7d8786","headings":[],"fields":{"slug":"/tutorial/e-data-protection-and-privacy/"}}},{"node":{"id":"48a7350b-c188-5631-9207-9ff5e68afb7e","headings":[{"value":"APPENDIX F: SSL/TLS certificates"}],"fields":{"slug":"/tutorial/f-certificates/"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"64c9ed3b-6893-5927-9d97-72bd14b54630"}}